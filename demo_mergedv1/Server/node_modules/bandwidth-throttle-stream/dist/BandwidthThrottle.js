"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _Platform_1 = require("./Platform/index");
const deferred_1 = require("./Util/deferred");
/**
 * A duplex stream transformer implementation, extending Node's built-in
 * `Transform` class. Receives input via a writable stream from a data
 * buffer (e.g. an HTTP request), and throttles output to a defined maximum
 * number of bytes per a defined interval.
 *
 * Configuration is received from a parent `BandwidthThrottleGroup` instance,
 * ensuring that available bandwidth is distributed evenly between all streams within
 * the group, mimicing the behaviour of overlapping network requests.
 */
class BandwidthThrottle extends _Platform_1.BaseTransformStream {
    constructor(
    /**
     * An object of configuration values provided by the
     * parent group.
     */
    config, 
    /**
     * The total number of bytes in the request to be throttled, to be used to define memory
     * allocation.
     */
    contentLength, 
    /**
     * A handler to be invoked whenever a request starts processing data,
     * so that the parent group can increment of the total number of
     * requests in flight across the group.
     */
    handleRequestStart, 
    /**
     * A handler to be invoked whenever a request stops processing
     * data, so that the parent group can decrement of the total
     * number of requests in flight across the group.
     */
    handleRequestEnd, 
    /**
     * A handler to be invoked when a request has finished processing all
     * data for a request, and the throttle is no longer needed.
     */
    handleRequestDestroy) {
        super({
            transform: (chunk) => this.transform(chunk),
            flush: () => this.flush()
        });
        /**
         * A callback to be invoked when bytes are written
         * to the underlying `readable` stream. Used as a hook
         * for testing to confirm output rate.
         */
        this.onBytesWritten = null;
        this.pendingBytesCount = 0;
        this.pendingBytesReadIndex = 0;
        this.isDataBeingWritten = false;
        this.done = deferred_1.default();
        this.config = config;
        this.pendingBytesBuffer = new Uint8Array(contentLength);
        this.handleRequestStart = handleRequestStart;
        this.handleRequestStop = handleRequestEnd;
        this.handleRequestDestroy = handleRequestDestroy;
    }
    /**
     * To be called when the request being throttled is aborted in
     * order to rebalance the available bandwidth.
     */
    abort() {
        this.handleRequestStop(this);
        this.destroy();
    }
    /**
     * Extracts a number of bytes from the pending bytes queue and
     * pushes it out to a piped writable stream.
     *
     * @returns The number of bytes processed through the throttle
     */
    process(maxBytesToProcess = Infinity) {
        const startReadIndex = this.pendingBytesReadIndex;
        const endReadIndex = Math.min(this.pendingBytesReadIndex + maxBytesToProcess, this.pendingBytesCount);
        const bytesToPushLength = endReadIndex - startReadIndex;
        if (bytesToPushLength > 0) {
            const bytesToPush = this.pendingBytesBuffer.subarray(startReadIndex, endReadIndex);
            this.pendingBytesReadIndex = endReadIndex;
            this.push(bytesToPush);
            if (typeof this.onBytesWritten === 'function') {
                this.onBytesWritten(bytesToPush);
            }
        }
        // Do not complete if:
        // - additional data is available to be processed,
        // - or, no additional data is available, but not all data has been written yet
        // - or, we are unthrottled
        if (this.pendingBytesReadIndex < this.pendingBytesCount ||
            this.isDataBeingWritten ||
            !this.config.isThrottled)
            return bytesToPushLength;
        // End the request
        this.done.resolve();
        this.handleRequestStop(this);
        this.destroy();
        return bytesToPushLength;
    }
    /**
     * Informs the parent group that the throttle is no longer needed and can
     * be released. Once a throttle is destroyed, it can not be used again.
     */
    destroy() {
        this.handleRequestDestroy(this);
        super.destroy();
    }
    /**
     * Invoked internally whenever data is received from the underlying
     * writeable stream. Resolves a promise when done.
     *
     * @param chunk A chunk of data in the form of a typed array of arbitrary length.
     */
    transform(chunk) {
        if (!this.isDataBeingWritten) {
            // If this is the first chunk of data to be processed, or
            // if is processing was previously paused due to a lack of
            // input signal that the request is in flight.
            this.handleRequestStart(this);
            this.isDataBeingWritten = true;
        }
        this.pendingBytesBuffer.set(chunk, this.pendingBytesCount);
        // Copy chunk data into queue and increment total queued bytes length
        this.pendingBytesCount += chunk.length;
        // If no throttling is applied, avoid any initial latency by immediately
        // processing the queue on the next frame.
        if (!this.config.isThrottled)
            this.process();
    }
    /**
     * Invoked once all data has been passed to the stream, and resolving a promise
     * when all data has been processed.
     */
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            // If an empty request was passed through the throttle, end immediately
            this.isDataBeingWritten = false;
            if (this.pendingBytesCount === 0)
                return;
            if (!this.config.isThrottled) {
                // If the throttle is unbounded, then all data has been
                // processed and request can be completed
                this.handleRequestStop(this);
                this.destroy();
                return;
            }
            // Else, wait for the processing cycle to compelte the request
            return this.done;
        });
    }
}
exports.default = BandwidthThrottle;
//# sourceMappingURL=BandwidthThrottle.js.map