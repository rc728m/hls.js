"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BandwidthThrottle_1 = require("./BandwidthThrottle");
const Config_1 = require("./Config");
const _Platform_1 = require("./Platform/index");
const getPartitionedIntegerPartAtIndex_1 = require("./Util/getPartitionedIntegerPartAtIndex");
/**
 * A class used to configure and bridge between one or more
 * `BandwidthThrottle` instances, ensuring that the defined
 * available bandwidth is distributed as equally as possible
 * between any simultaneous requests.
 *
 * A `BandwidthThrottleGroup` instance must always be created
 * before attaching individual `throttle` instances to it via
 * its `createBandwidthThrottle()` method.
 */
class BandwidthThrottleGroup {
    /**
     * @param options Consumer-provided options defining the
     *  throttling behaviour.
     */
    constructor(options) {
        this.config = new Config_1.default();
        /**
         * An optional callback providing the consumer with metrics pertaining to the throttle
         * group's average throughput and utlization percentage.
         */
        this.onThroughputMetrics = null;
        this.inFlightRequests = [];
        this.bandwidthThrottles = [];
        this.clockIntervalId = null;
        this.pollThroughputIntervalId = this.pollThroughput();
        this.lastTickTime = -1;
        this.tickIndex = 0;
        this.secondIndex = 0;
        this.totalBytesProcessed = 0;
        Object.assign(this.config, options);
        this.createBandwidthThrottle = this.createBandwidthThrottle.bind(this);
        this.handleRequestStop = this.handleRequestStop.bind(this);
        this.handleRequestStart = this.handleRequestStart.bind(this);
        this.handleRequestDestroy = this.handleRequestDestroy.bind(this);
        this.processInFlightRequests = this.processInFlightRequests.bind(this);
    }
    get hasTicked() {
        return this.lastTickTime > -1;
    }
    get isTicking() {
        return this.clockIntervalId !== null;
    }
    configure(options) {
        Object.assign(this.config, options);
    }
    /**
     * Creates and returns a pipeable `BandwidthThrottle` transform stream,
     * and attaches it to the group.
     *
     * @param contentLength The total number of bytes for the request to be throttled.
     */
    createBandwidthThrottle(contentLength) {
        const bandwidthThrottle = new BandwidthThrottle_1.default(this.config, contentLength, this.handleRequestStart, this.handleRequestStop, this.handleRequestDestroy);
        this.bandwidthThrottles.push(bandwidthThrottle);
        return bandwidthThrottle;
    }
    /**
     * Destroys all bandwidth throttle instances in the group, terminating
     * any running intervals, such that the entire group may be garbage
     * collected.
     */
    destroy() {
        clearInterval(this.pollThroughputIntervalId);
        while (this.bandwidthThrottles.length)
            this.bandwidthThrottles.pop().destroy();
    }
    /**
     * Increments the number of "in-flight" requests when a request in any
     * attached `BandwidthThrottle` instance starts.
     */
    handleRequestStart(bandwidthThrottle) {
        this.inFlightRequests.push(bandwidthThrottle);
        if (this.clockIntervalId)
            return;
        // Start the processing clock when the first request starts
        this.clockIntervalId = this.startClock();
    }
    /**
     * Removes the reference of a throttle from the `inFlightRequests` array
     * in order to redistribute bandwidth while a request is inactive or after
     * it has ended.
     *
     * If noÂ other in flight requets are active at that point, the internal
     * clock is stopped to save resources.
     */
    handleRequestStop(bandwidthThrottle) {
        this.inFlightRequests.splice(this.inFlightRequests.indexOf(bandwidthThrottle), 1);
        if (this.inFlightRequests.length === 0)
            this.stopClock();
    }
    /**
     * Releases a destroyed throttle from memory.
     */
    handleRequestDestroy(bandwidthThrottle) {
        this.bandwidthThrottles.splice(this.bandwidthThrottles.indexOf(bandwidthThrottle), 1);
    }
    /**
     * Starts the "clock" ensuring that all incoming data will be processed at
     * a constant rate, defined by `config.resolutionHz`.
     */
    startClock() {
        // NB: We iterate at a rate 5x faster than the desired tick duration.
        // This seems to greatly increase the likelyhood of the actual ticks
        // occuring at the intended time.
        return _Platform_1.setInterval(this.processInFlightRequests, this.config.tickDurationMs / 5);
    }
    /**
     * Stops the clock and resets counters while no requests are active.
     */
    stopClock() {
        clearInterval(this.clockIntervalId);
        this.clockIntervalId = null;
        this.tickIndex = 0;
        this.secondIndex = 0;
        this.lastTickTime = -1;
    }
    /**
     * On each tick, processes the maximum allowable amount of data
     * through each active request.
     */
    processInFlightRequests() {
        // Check the time since data was last processed
        const now = Date.now();
        const elapsedTime = this.hasTicked ? now - this.lastTickTime : 0;
        // If throttling active and not the first tick and
        // the time elapsed is less than the provided interval
        // duration, do nothing.
        if (this.config.isThrottled &&
            this.hasTicked &&
            elapsedTime < this.config.tickDurationMs)
            return;
        // If we have not achieved our `tickDurationMs` goal, then create a multiplier
        // to augment the amount of data sent for the tick, proportional to the delay
        const delayMultiplier = Math.max(1, elapsedTime / this.config.tickDurationMs);
        const period = this.secondIndex % this.inFlightRequests.length;
        for (let i = 0; i < this.inFlightRequests.length; i++) {
            // Step 1 - evenly destribute bytes between active requests. If cannot
            // be evenly divided, use per second rotation to balance
            // Step 2 - for each individual request, distribute over resolution
            const currentInFlightRequestsCount = this.inFlightRequests.length;
            const bandwidthThrottle = this.inFlightRequests[i];
            const rotatedIndex = (i + period) % currentInFlightRequestsCount;
            const bytesPerRequestPerSecond = getPartitionedIntegerPartAtIndex_1.default(this.config.bytesPerSecond, this.inFlightRequests.length, rotatedIndex);
            const bytesPerRequestPerTick = getPartitionedIntegerPartAtIndex_1.default(bytesPerRequestPerSecond, this.config.ticksPerSecond, this.tickIndex);
            const bytesProcessed = bandwidthThrottle.process(bytesPerRequestPerTick * delayMultiplier);
            this.totalBytesProcessed += bytesProcessed;
            if (this.inFlightRequests.length < currentInFlightRequestsCount) {
                i--;
            }
        }
        // If the clock has been stopped because a call to `.process()`
        // completed the last active request, then do not update state.
        if (!this.isTicking)
            return;
        this.tickIndex++;
        // Increment the tick index, or reset it to 0 whenever it surpasses
        // the desired resolution
        if (this.tickIndex === this.config.ticksPerSecond) {
            this.tickIndex = 0;
            this.secondIndex++;
        }
        // Increment the last push time, and return
        this.lastTickTime = this.hasTicked
            ? this.lastTickTime + elapsedTime
            : now;
    }
    pollThroughput() {
        const bytesPerSecondSamples = [];
        const perSecondMultipler = 1000 / this.config.throughputSampleIntervalMs;
        let lastHeapRead = 0;
        return _Platform_1.setInterval(() => {
            const bytesSinceLastSample = Math.max(0, this.totalBytesProcessed - lastHeapRead);
            lastHeapRead = this.totalBytesProcessed;
            bytesPerSecondSamples.push(bytesSinceLastSample);
            if (bytesSinceLastSample === 0)
                this.totalBytesProcessed = 0;
            if (bytesPerSecondSamples.length > this.config.throughputSampleSize)
                bytesPerSecondSamples.shift();
            const averageBytesPerSecond = (bytesPerSecondSamples.reduce((sum, sample) => sum + sample, 0) /
                bytesPerSecondSamples.length) *
                perSecondMultipler;
            if (typeof this.onThroughputMetrics === 'function') {
                this.onThroughputMetrics({
                    averageBytesPerSecond,
                    utilization: Math.min(1, averageBytesPerSecond / this.config.bytesPerSecond)
                });
            }
        }, this.config.throughputSampleIntervalMs);
    }
}
exports.default = BandwidthThrottleGroup;
//# sourceMappingURL=BandwidthThrottleGroup.js.map